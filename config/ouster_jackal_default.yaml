/**:
  ros__parameters:
    log_to_file: true
    log_debug: true
    log_enabled:
      - navigation
      # - navigation.graph_map_server
      # - navigation.command
        # tactic
      - tactic # for luka
      - tactic.pipeline # for luka
      - tactic.module # GOOD speed on to check; for luka
      # - tactic.module.live_mem_manager # for luka
      # - tactic.module.graph_mem_manager # for luka
      - mission.state_machine
      - mission.server
      - navigator
      - route_planning  # HSHMAT: Enable route planning logs (including route_planning.bfs)
        # planner manager
      - cbit.control # for luka
      - cbit.debug # for luka 
      - cbit.path_planning # for luka
      - cbit.visualization # for luka
      - cbit.obstacle_filtering # for luka
      #- grizzly_controller_tests.cbit
        # mpc
      # - mpc.speed_scheduler
      - mpc.debug
      - test
      #- mpc.solver
        # path planner
      # - cbit_planner.path_planning
        # pose graph
      #- pose_graph
        # lidar pipeline
      #- lidar.pipeline
      #- lidar.honeycomb_converter
      # - lidar.preprocessing
      #- lidar.odometry_icp
      #- lidar.odometry_map_maintenance
      #- lidar.vertex_test
      #- lidar.localization_map_recall
      #- lidar.localization_icp
      #- lidar.intra_exp_merging
      #- lidar.dynamic_detection
      #- lidar.inter_exp_merging
      #- lidar.ground_extraction
      #- lidar.obstacle_detection
      #- lidar.terrain_assessment
    # control frame from the urdf
    robot_frame: os_sensor #base_link
    env_info_topic: env_info
    lidar_frame: os_lidar
    lidar_topic: /ouster/points
    route_planning:
      enable_reroute: true   # Enable obstacle-triggered rerouting
      permanent_ban: false   # Keep bans across replanning attempts
      replanner_type: "deterministic_timecost"  # or "masked_bfs"
      nominal_speed_mps: 0.8                    # robot nominal forward speed (m/s)
      obstacle_delay_person: 0.0                # extra delay (s) for person obstacles
      obstacle_delay_chair: 10000.0                # extra delay (s) for chair/ static obstacles
    graph_projection:
      # # UTIAS coordinates (original)
      # origin_lat: 43.7822  # UTIAS
      # origin_lng: -79.4661 # UTIAS
      # # Myhal Centre coordinates (accurate)
      # origin_lat: 43.660837  # Myhal Centre (accurate coordinates)
      # origin_lng: -79.396485 # Myhal Centre (accurate coordinates)
      # # Robot starting position (adjusted 0.5m left, 0.2m up)
      origin_lat: 43.6607740  # increasing this seems to move up on the map
      origin_lng: -79.3966100 # increasing this seems to move left on the map
      origin_theta: 1.9
      scale: 1.0
      gps_topic: "/novatel/fix"
    tactic:
      enable_parallelization: true
      preprocessing_skippable: false
      odometry_mapping_skippable: false
      localization_skippable: false
      task_queue_num_threads: 1
      task_queue_size: -1
      
      route_completion_translation_threshold: 0.10 # tactic.cpp route completed. # for RL this has to be smaller than the RL threshold so that we can get the localization results and stuff
      route_completion_angle_threshold: 0.1 #0.26

      chain:
        min_cusp_distance: 1.5
        angle_weight: 0.25
        search_depth: 6
        search_back_depth: 5
        distance_warning: 5.0
        alpha: 0.15 #0.25 # the one in genreate_pq is not used.
      save_odometry_result: true
      save_localization_result: true
      visualize: true
      rviz_loc_path_offset:
        - 0.0
        - 0.0
        - 0.0
    pipeline:
      type: lidar
      preprocessing:
        - conversion
        - filtering
      odometry:
        - icp
        - mapping
        - vertex_test
        # - intra_exp_merging
        # - dynamic_detection
        # - inter_exp_merging
        - memory
      localization:
        - recall
        - icp
        # - safe_corridor
        # - change_detection_sync
        - memory
      submap_translation_threshold: 0.325 
      submap_rotation_threshold: 20.0
    preprocessing:
      conversion:
        type: lidar.ouster_converter
        visualize: false # JH: could add additional filters here?
        filter_warthog: true # look at code: need to be true to filter
        filter_z_min: -0.5
        filter_z_max: 2.5
        filter_radius: 0.5 # was 0.2

      filtering:
        type:  lidar.preprocessing #lidar.preprocessing_v2
        num_threads: 4
        crop_range: 20.0

        frame_voxel_size: 0.3 #0.3 # grid subsampling voxel size

        vertical_angle_res: 0.0122718463 # (pi/2)/128 for OS0 128
        polar_r_scale: 2.0 # polar_r_scale x vertical_angle_res = nearest neighbor search radius for normal computation
        r_scale: 2.5 # scale down point range by this value after taking log, whatever works
        h_scale: 0.5 # scale down yaw(phi) by this value so that vertical resolution ~= horizontal resolution, horizontal resolution is 360/1024 ~= 0.3516 degree, so 0.3516 / (90/128) = 0.5. OR for 360/512 = 0.7031, 0.7031 / (90/128) = 1.0

        num_sample1: 4000 #12500 # max number of sample after filtering based on planarity
        min_norm_score1: 0.95 # min planarity score

        num_sample2: 4000 #12500 # max number of sample after filtering based on planarity
        min_norm_score2: 0.2 # 0.2 is when the incident angle 5/12 * pi
        min_normal_estimate_dist: 1.0 # minimum distance to estimate normal in meters
        max_normal_estimate_angle: 0.44 # must <1/2, this value will be timed by M_PI

        cluster_num_sample: 4000 #12500 # maxnumber of sample after removing isolated points

        visualize: false
    odometry:
      icp:
        type: lidar.odometry_icp

        # continuous time estimation
        use_trajectory_estimation: false
        traj_num_extra_states: 0
        traj_lock_prev_pose: false
        traj_lock_prev_vel: false
        traj_qc_diag:
          - 1.0
          - 0.1
          - 0.1
          - 0.1
          - 0.1
          - 1.0
        num_threads: 4
        first_num_steps: 2
        initial_max_iter: 4
        initial_max_pairing_dist: 1.5
        initial_max_planar_dist: 1.0
        refined_max_iter: 50
        refined_max_pairing_dist: 1.0
        refined_max_planar_dist: 0.3
        averaging_num_steps: 2
        verbose: false
        max_iterations: 1
        min_matched_ratio: 0.5
        visualize: false
      mapping:
        type: lidar.odometry_map_maintenance_v2

        map_voxel_size: 0.25

        crop_range_front: 40.0
        back_over_front_ratio: 0.5
        point_life_time: 20.0
        visualize: false
      vertex_test:
        type: lidar.vertex_test

        max_translation: 0.3 # JH: Alec mentioned something about if this is too small, weird things will happen
        max_rotation: 15.0
      intra_exp_merging:
        type: lidar.intra_exp_merging_v2
        depth: 6.0

        map_voxel_size: 0.3

        crop_range_front: 40.0
        back_over_front_ratio: 0.5
        visualize: false
      dynamic_detection:
        type: lidar.dynamic_detection
        depth: 12.0

        horizontal_resolution: 0.00613592315  # 2pi / 1024
        vertical_resolution: 0.0122718463  # pi/2 / 128
        max_num_observations: 10000
        min_num_observations: 4
        dynamic_threshold: 0.3
        visualize: false
      inter_exp_merging:
        type: "lidar.inter_exp_merging_v2"

        map_voxel_size: 0.25
        max_num_experiences: 128
        distance_threshold: 0.6
        planar_threshold: 0.2
        normal_threshold: 0.8
        dynamic_obs_threshold: 1
        visualize: false
      memory:
        type: live_mem_manager
        window_size: 5
    localization:
      recall:
        type: lidar.localization_map_recall
        map_version: pointmap
        visualize: false
      icp:
        type: lidar.localization_icp
        use_pose_prior: true
        num_threads: 4
        first_num_steps: 2
        initial_max_iter: 4
        initial_max_pairing_dist: 1.5
        initial_max_planar_dist: 1.0
        refined_max_iter: 50
        refined_max_pairing_dist: 1.0
        refined_max_planar_dist: 0.3
        averaging_num_steps: 2
        verbose: false
        max_iterations: 1
        min_matched_ratio: 0.3
      safe_corridor:
        type: lidar.safe_corridor
        lookahead_distance: 5.0
        corridor_width: 0.5
        influence_distance: 1.0
        resolution: 0.25
        size_x: 16.0
        size_y: 8.0
        visualize: false
      change_detection_sync:
        type: lidar.change_detection_v3
        detection_range: 8.0
        search_radius: 0.25

        negprob_threshold: 0.25 # was 0.015 # -1.86 without prior, 0.015 with prior
        use_prior: true
        alpha0: 3.0
        beta0: 0.03
        use_support_filtering: true
        support_radius: 0.25
        support_variance: 0.05
        support_threshold: 2.5

        influence_distance: 0.5 # Note that the total distance where grid cells have values > 0 is min dist + influence dist, not influence dist!
        minimum_distance: 0.8

        # cost map
        costmap_history_size: 15 # Keep between 3 and 30, used for temporal filtering
        resolution: 0.25
        size_x: 16.0
        size_y: 8.0
        visualize: false
      change_detection:
        type: lidar.change_detection_v2
        detection_range: 8
        search_radius: 0.25
        negprob_threshold: 0.1
        use_prior: true
        alpha0: 3.0
        beta0: 0.03
        use_support_filtering: true
        support_radius: 0.25
        support_variance: 0.05
        support_threshold: 2.5
        resolution: 0.5
        size_x: 16.0
        size_y: 8.0
        run_online: false
        run_async: true
        visualize: false
        save_module_result: false
      memory:
        type: graph_mem_manager
        vertex_life_span: 5
        window_size: 3
      obstacle_detection:
        type: lidar.obstacle_detection
        z_min: 0.5 
        z_max: 2.0
        resolution: 0.6
        size_x: 40.0
        size_y: 20.0
        run_async: true
        visualize: false
      ground_extraction:
        type: lidar.ground_extraction
        z_offset: 0.2
        alpha: 0.035
        tolerance: 0.25
        Tm: 0.3
        Tm_small: 0.1
        Tb: 0.5
        Trmse: 0.1
        Tdprev: 1.0
        rmin: 2.0
        num_bins_small: 30.0
        bin_size_small: 0.5
        num_bins_large: 10.0
        bin_size_large: 1.0
        resolution: 0.6
        size_x: 40.0
        size_y: 20.0
        run_async: true
        visualize: false
      terrain_assessment:
        type: lidar.terrain_assessment
        lookahead_distance: 15.0
        corridor_width: 1.0
        search_radius: 1.0
        resolution: 0.5
        size_x: 40.0
        size_y: 20.0
        run_online: false
        run_async: true
        visualize: false

    path_planning:
      type: cbit
      control_period: 100 # ms
      cbit:
        obstacle_avoidance: false
        obs_padding: 0.0
        curv_to_euclid_discretization: 10
        sliding_window_width: 12.0
        sliding_window_freespace_padding: 0.5
        corridor_resolution: 0.2
        state_update_freq: 2.0
        update_state: true
        rand_seed: 1

        # Planner Tuning Params
        initial_samples: 400
        batch_samples: 200
        pre_seed_resolution: 0.5
        alpha: 0.25
        q_max: 2.5
        frame_interval: 50
        iter_max: 10000000
        eta: 1.0
        rad_m_exhange: 1.00
        initial_exp_rad: 1.00
        extrapolation: false
        incremental_plotting: false
        plotting: true
      costmap:
        costmap_filter_value: 0.01
        costmap_history: 15 

      speed_scheduler:
        planar_curv_weight: 2.50
        profile_curv_weight: 0.5 
        eop_weight: 1.0
        min_vel: 0.5

      mpc:
        # Controller Params
        extrapolate_robot_pose: false
        mpc_verbosity: false
        homotopy_guided_mpc: false
        horizon_steps: 20
        horizon_step_size: 0.25 # JH: I think this is planning time step which I need to be 0.25s for DRL model.
        forward_vel: 1.0 #hsh, used to be0.9
        max_lin_vel: 1.0 # hsh, used to be 1.0 #1.0
        max_ang_vel: 1.0 # hsh, used to be 1.0 #1.0
        robot_linear_velocity_scale: 1.0 # Used to scale the output twist linear velocity messages by some constant factor to compensate internal low level control miscalibration
        robot_angular_velocity_scale: 1.0 # Used to scale the output twist angular velocity messages by some constant factor to compensate internal low level control miscalibration

        vehicle_model: "unicycle"

        # JH: I think Alec changed this to just rollout which removes kinematic constraints as part of optimization
        # Cost Function Covariance Matrices
        pose_error_cov: [10.0, 10.0, 100.0, 100.0, 100.0, 20.0]
        vel_error_cov: [20.0, 30.0]
        acc_error_cov: [20.0, 20.0]
        kin_error_cov: [0.01, 0.01, 0.01, 0.01, 0.01, 0.01]
        lat_error_cov: [2.0]

        # Cost Function Weights
        pose_error_weight: 1.0
        vel_error_weight: 1.5
        acc_error_weight: 1.5
        kin_error_weight: 1.0
        lat_error_weight: 0.01

        # Misc
        command_history_length: 100